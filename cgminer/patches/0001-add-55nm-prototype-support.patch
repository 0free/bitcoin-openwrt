From 167b1b6ee537de01e107e1d82f041fc0f91fd2ec Mon Sep 17 00:00:00 2001
From: Xiangfu <xiangfu@openmobilefree.net>
Date: Fri, 8 Nov 2013 01:03:01 +0800
Subject: [PATCH] add 55nm prototype support

---
 driver-avalon.c | 100 ++++++++++++++++++++++++++++++++++++++++++++++----------
 driver-avalon.h |   3 +-
 2 files changed, 84 insertions(+), 19 deletions(-)

diff --git a/driver-avalon.c b/driver-avalon.c
index 53704e9..b0df7fa 100644
--- a/driver-avalon.c
+++ b/driver-avalon.c
@@ -59,7 +59,7 @@ static int avalon_init_task(struct avalon_task *at,
 			    uint8_t reset, uint8_t ff, uint8_t fan,
 			    uint8_t timeout, uint8_t asic_num,
 			    uint8_t miner_num, uint8_t nonce_elf,
-			    uint8_t gate_miner, int frequency)
+			    uint8_t gate_miner, int frequency, int asic)
 {
 	uint16_t *lefreq16;
 	uint8_t *buf;
@@ -109,8 +109,58 @@ static int avalon_init_task(struct avalon_task *at,
 	buf[9] = 0x01;
 	buf[10] = 0x00;
 	buf[11] = 0x00;
-	lefreq16 = (uint16_t *)&buf[6];
-	*lefreq16 = htole16(frequency * 8);
+
+	if (asic == 110) {
+		lefreq16 = (uint16_t *)&buf[6];
+		*lefreq16 = htole16(frequency * 8);
+	} else {
+		switch (frequency / 2) { /* This is the real clock, Mhz */
+		case 500:
+			buf[6] = 0xe0;
+			buf[7] = 0x94;
+			break;
+		case 550:
+			buf[6] = 0xa0;
+			buf[7] = 0x82;
+			break;
+		case 600:
+			buf[6] = 0xe0;
+			buf[7] = 0x82;
+			break;
+		case 650:
+			buf[6] = 0x20;
+			buf[7] = 0x83;
+			break;
+		case 700:
+			buf[6] = 0x60;
+			buf[7] = 0x83;
+			break;
+		case 750:
+			buf[6] = 0xa0;
+			buf[7] = 0x83;
+			break;
+		case 800:
+			buf[6] = 0xe0;
+			buf[7] = 0x83;
+			break;
+		case 850:
+			buf[6] = 0x20;
+			buf[7] = 0x84;
+			break;
+		case 900:
+			buf[6] = 0x60;
+			buf[7] = 0x84;
+			break;
+		case 950:
+			buf[6] = 0xa0;
+			buf[7] = 0x84;
+			break;
+		case 1000:
+			buf[6] = 0xe0;
+			buf[7] = 0x84;
+			break;
+		}
+	}
 
 	return 0;
 }
@@ -316,7 +366,8 @@ static int avalon_reset(struct cgpu_info *avalon, bool initial)
 			 AVALON_DEFAULT_ASIC_NUM,
 			 AVALON_DEFAULT_MINER_NUM,
 			 0, 0,
-			 AVALON_DEFAULT_FREQUENCY);
+			 AVALON_DEFAULT_FREQUENCY,
+			 110);
 
 	wait_avalon_ready(avalon);
 	ret = avalon_send_task(&at, avalon);
@@ -378,16 +429,16 @@ static int avalon_reset(struct cgpu_info *avalon, bool initial)
 	return 0;
 }
 
-static int avalon_calc_timeout(int frequency)
+static int avalon_calc_timeout(int frequency, int asic)
 {
-	return AVALON_TIMEOUT_FACTOR / frequency;
+	return (AVALON_TIMEOUT_FACTOR / (110 / asic)) / frequency;
 }
 
 static bool get_options(int this_option_offset, int *baud, int *miner_count,
-			int *asic_count, int *timeout, int *frequency, char *options)
+			int *asic_count, int *timeout, int *frequency, int *asic, char *options)
 {
 	char buf[BUFSIZ+1];
-	char *ptr, *comma, *colon, *colon2, *colon3, *colon4;
+	char *ptr, *comma, *colon, *colon2, *colon3, *colon4, *colon5;
 	bool timeout_default;
 	size_t max;
 	int i, tmp;
@@ -490,6 +541,10 @@ static bool get_options(int this_option_offset, int *baud, int *miner_count,
 					}
 				}
 				if (colon4 && *colon4) {
+					colon5 = strchr(colon4, ':');
+					if (colon5)
+						*(colon5++) = '\0';
+
 					tmp = atoi(colon4);
 					if (tmp < AVALON_MIN_FREQUENCY || tmp > AVALON_MAX_FREQUENCY) {
 						quit(1, "Invalid avalon-options for frequency, must be %d <= frequency <= %d",
@@ -497,7 +552,13 @@ static bool get_options(int this_option_offset, int *baud, int *miner_count,
 					}
 					*frequency = tmp;
 					if (timeout_default)
-						*timeout = avalon_calc_timeout(*frequency);
+						*timeout = avalon_calc_timeout(*frequency, 110);
+					if (colon5 && *colon5) {
+						tmp = atoi(colon5);
+						if (tmp != 110 && tmp != 55)
+							quit(1, "Invalid avalon-options for asic, must be 110 or 55");
+						*asic = tmp;
+					}
 				}
 			}
 		}
@@ -559,7 +620,7 @@ static void avalon_idle(struct cgpu_info *avalon, struct avalon_info *info)
 		info->idle++;
 		avalon_init_task(&at, 0, 0, info->fan_pwm, info->timeout,
 				 info->asic_count, info->miner_count, 1, 1,
-				 info->frequency);
+				 info->frequency, info->asic);
 		avalon_send_task(&at, avalon);
 	}
 	applog(LOG_WARNING, "%s%i: Idling %d miners", avalon->drv->name, avalon->device_id, i);
@@ -737,7 +798,7 @@ static void bitburner_get_version(struct cgpu_info *avalon)
 
 static bool avalon_detect_one(libusb_device *dev, struct usb_find_devices *found)
 {
-	int baud, miner_count, asic_count, timeout, frequency;
+	int baud, miner_count, asic_count, timeout, frequency, asic;
 	int this_option_offset;
 	struct avalon_info *info;
 	struct cgpu_info *avalon;
@@ -751,13 +812,14 @@ static bool avalon_detect_one(libusb_device *dev, struct usb_find_devices *found
 	asic_count = AVALON_DEFAULT_ASIC_NUM;
 	timeout = AVALON_DEFAULT_TIMEOUT;
 	frequency = AVALON_DEFAULT_FREQUENCY;
+	asic = 110;
 
 	if (!usb_init(avalon, dev, found))
 		goto shin;
 
 	this_option_offset = usb_ident(avalon) == IDENT_BBF ? ++bbf_option_offset : ++option_offset;
 	configured = get_options(this_option_offset, &baud, &miner_count,
-				 &asic_count, &timeout, &frequency,
+				 &asic_count, &timeout, &frequency, &asic,
 				 (usb_ident(avalon) == IDENT_BBF && opt_bitburner_fury_options != NULL) ? opt_bitburner_fury_options : opt_avalon_options);
 
 	avalon->usbdev->usb_type = USB_TYPE_FTDI;
@@ -771,12 +833,14 @@ static bool avalon_detect_one(libusb_device *dev, struct usb_find_devices *found
 	info = avalon->device_data;
 
 	if (configured) {
+		info->asic = asic;
 		info->baud = baud;
 		info->miner_count = miner_count;
 		info->asic_count = asic_count;
 		info->timeout = timeout;
 		info->frequency = frequency;
 	} else {
+		info->asic = 110;
 		info->baud = AVALON_IO_SPEED;
 		info->asic_count = AVALON_DEFAULT_ASIC_NUM;
 		switch (usb_ident(avalon)) {
@@ -1019,7 +1083,7 @@ static void bitburner_rotate_array(struct cgpu_info *avalon)
 
 static void avalon_set_timeout(struct avalon_info *info)
 {
-	info->timeout = avalon_calc_timeout(info->frequency);
+	info->timeout = avalon_calc_timeout(info->frequency, info->asic);
 }
 
 static void avalon_set_freq(struct cgpu_info *avalon, int frequency)
@@ -1113,7 +1177,7 @@ static void *avalon_send_tasks(void *userdata)
 		avalon_adjust_freq(info, avalon);
 
 		/* A full nonce range */
-		us_timeout = 0x100000000ll / info->asic_count / info->frequency;
+		us_timeout = 0x100000000ll / info->asic_count / info->frequency / (110 / info->asic);
 		cgsleep_prepare_r(&ts_start);
 
 		mutex_lock(&info->qlock);
@@ -1130,7 +1194,7 @@ static void *avalon_send_tasks(void *userdata)
 			if (likely(j < avalon->queued && !info->overheat && avalon->works[i])) {
 				avalon_init_task(&at, 0, 0, info->fan_pwm,
 						info->timeout, info->asic_count,
-						info->miner_count, 1, 0, info->frequency);
+						info->miner_count, 1, 0, info->frequency, info->asic);
 				avalon_create_task(&at, avalon->works[i]);
 				info->auto_queued++;
 			} else {
@@ -1142,7 +1206,7 @@ static void *avalon_send_tasks(void *userdata)
 					idle_freq = AVALON_MIN_FREQUENCY;
 				avalon_init_task(&at, 0, 0, info->fan_pwm,
 						info->timeout, info->asic_count,
-						info->miner_count, 1, 1, idle_freq);
+						info->miner_count, 1, 1, idle_freq, info->asic);
 				/* Reset the auto_queued count if we end up
 				 * idling any miners. */
 				avalon_reset_auto(info);
@@ -1216,7 +1280,7 @@ static void *bitburner_send_tasks(void *userdata)
 			if (likely(j < avalon->queued && !info->overheat && avalon->works[i])) {
 				avalon_init_task(&at, 0, 0, info->fan_pwm,
 						info->timeout, info->asic_count,
-						info->miner_count, 1, 0, info->frequency);
+						info->miner_count, 1, 0, info->frequency, info->asic);
 				avalon_create_task(&at, avalon->works[i]);
 				info->auto_queued++;
 			} else {
@@ -1228,7 +1292,7 @@ static void *bitburner_send_tasks(void *userdata)
 					idle_freq = AVALON_MIN_FREQUENCY;
 				avalon_init_task(&at, 0, 0, info->fan_pwm,
 						info->timeout, info->asic_count,
-						info->miner_count, 1, 1, idle_freq);
+						info->miner_count, 1, 1, idle_freq, info->asic);
 				/* Reset the auto_queued count if we end up
 				 * idling any miners. */
 				avalon_reset_auto(info);
diff --git a/driver-avalon.h b/driver-avalon.h
index ea32bc0..296d9ac 100644
--- a/driver-avalon.h
+++ b/driver-avalon.h
@@ -48,7 +48,7 @@
 
 #define AVALON_DEFAULT_TIMEOUT 0x2D
 #define AVALON_MIN_FREQUENCY 256
-#define AVALON_MAX_FREQUENCY 1024
+#define AVALON_MAX_FREQUENCY 2000
 #define AVALON_TIMEOUT_FACTOR 12690
 #define AVALON_DEFAULT_FREQUENCY 282
 #define AVALON_DEFAULT_MINER_NUM 0x20
@@ -136,6 +136,7 @@ struct avalon_info {
 	int matching_work[AVALON_MAX_MINER_NUM];
 
 	int frequency;
+	int asic;
 	uint32_t ctlr_ver;
 
 	struct thr_info *thr;
-- 
1.8.1.2

